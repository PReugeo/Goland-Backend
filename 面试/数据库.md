数据库 E-R 图

![这里写图片描述](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/20151225202551167)



SQL **语句分类**

DDL &mdash;数据定义语言(CREATE，ALTER，DROP，DECLARE)

DML &mdash;数据操纵语言(SELECT，DELETE，UPDATE，INSERT)

DCL &mdash;数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK)

当关系S自然联接时，能够把S原该舍弃的元组放到结果关系中的操作是外连接

左外联接以左边关系为参照系，将所有左边关系的元组以及右边关系中满足条件的元组放到结果关系中。 

右外联接以右边关系为参照系，将所有右边关系的元组以及左边关系中满足条件的元组放到结果关系中。
左外联接能够把 R 中原该舍弃的元组放到结果关系中，但不能把 S 中原该舍弃的元组放到结果关系中。右外联接能够把S 中原该舍弃的元组放到结果关系中，但不能把R中原该舍弃的元组放到结果关系中。

**Inner Join**

![l](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/l.png)

**Left Join**

![l](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/l-1597656934126.png)

**Right Join**

![l](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/l-1597656972056.png)





## MySQL

### 1.索引相关

#### 1. 索引是什么? 具体是什么数据结构?

1. 索引是一种数据结构, 能够帮助我们快速检索数据库中的数据
2. MySQL 主要有两种数据结构: Hash 索引和  B+ Tree 索引, InnoDB 引擎,默认使用 B+Tree

索引的种类：

* 普通索引
* 联合索引
* 主键索引
* 全文索引
* 唯一索引

#### 2. B + 树和 Hash 索引的比较有什么优缺点?

1. 哈希索引只适合等值查询, 但是无法进行范围查询
2. 哈希索引无法进行排序
3. 哈希索引不支持多列联合索引的最左匹配规则
4. 如果有大量重复值存在, 哈希索引效率会很低, 因为存在哈希碰撞问题

#### 3. B+ 树是什么?

​	B + 树一种多路平衡查找树, 结构如下:

![img](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/1383122-20200510121023476-1149349624.png)

​	其叶子节点是一个双向循环链表, 在范围查询中, 只用找到一个数据, 就可以直接返回剩余的数据. 且数据仅存在于叶子节点, 其扩充规律如下:

![img](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/1383122-20200510121103015-569225302.png)

B 树是父节点也存在数据的 B+ 树, 且叶子结点不存在指针.



好处:

* B+ 树的磁盘读写代价更低
* 查询效率更加稳定
* 更有利于对数据库的扫描

#### 4. B 树是什么？

m 阶 B 树定义：

* 根节点至少包含两个孩子
* 树中每个节点最多含有 m 个孩子 （ $m \geq 2$ ）
* 除了根节点和叶节点外，其他每个节点至少有 ceil(m / 2) 个孩子
* 所有叶子节点都位于同一层

![img](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/v2-a0f981fc847772cb28869927cd4fe66d_r.jpg)

#### 5. B + Tree **的叶子节点都可以存什么东西**?  聚簇索引和非聚簇索引(密集索引和稀疏索引)

InnoDB 的可能存储整行数据, 也可能是主键的值 . 

聚簇索引叶子节点就是数据节点，非聚簇索引叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

聚簇索引和非聚簇索引的区别是: **叶子节点是否存储整行记录**.

InnoDB 主要使用聚簇索引, MyISAM 主键索引和二级索引都是使用非聚簇索引. 

聚簇索引, 表数据和主键一起存储的, 非聚簇索引是分开存储的. 

**聚簇索引的优点:**

1. 取出范围数据时, 其查询速度比非聚簇索引快
2. 查找目标数据时理论上比非聚簇索引要快, 因为非聚簇索引定位到对应主键时还要多一次目标记录寻址, 即多一次 I/O
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

**聚簇索引的缺点**

1. 插入速度严重依赖于插入顺序
2. 更新主键代价很高, 因为会导致被更新的行移动
3. 二次索引访问需要两次索引查找, 第一次找到主键值, 第二次根据主键找到数据
4. 插入速度比非聚簇索引慢很多

**聚簇索引和非聚簇索引查询如下图所示**

![image-20200714212122701](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200714212122701.png)

聚簇索引的辅助键索引需要先找到主键索引然后再查询到数据。

非聚簇索引的主键索引和非主键索引都可以直接通过索引寻址来查询到数据



#### 6. 非聚簇索引查询时一定会查询多次吗?

不一定, 可以通过覆盖索引可以只查询一次. *覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。*



#### 7. 索引是建立的越多越好吗

* 数据量小的表不需要建立索引，建立会增加额外得索引开销
* 数据变更需要维护索引， 因此更多的索引意味着更多的维护成本
* 更多的索引意味着需要更多的空间



#### 8. 联合索引最左前缀匹配及其成因

创建联合索引的适合会将识别度最高的字段放到最前面. 因为 MySQL 索引查询会遵循最左前缀匹配原则, 即最左优先. 

![image-20200715095241219](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200715095241219.png)

联合索引会首先对最左边的索引进行排序，然后在对其后的索引进行排序，如该图，创建 (col3, col2) 索引，MySQL 创建的 B + 树大致如图所示。

![image-20200716115249605](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/image-20200716115249605.png)



#### 9.索引优化

1. **独立查询**

    索引列不能是函数参数也不能参与表达式，否则无法使用索引

2. **最左匹配原则**

3. **尽量扩展索引而非新建索引**

4. **尽量使用覆盖索引**

5. **选择区分度高的列作为索引**

    区分度： `count(distinct col)/count(*)`



#### 10. 优化慢查询 sql

1. 根据慢日志定位慢查询 sql
2. 使用 explain 等工具分析 sql
    1. Explain 重要字段有
        1. `select_type`： 查询类型，有简单查询、联合查询、子查询等
        2. `key`：使用的索引
        3. `rows`：扫描的行数
3. 修改 sql 或者尽量让 sql 走索引
    1. 减少请求数据量：
        * 只返回必要的列：不用 `select *`
        * 只返回必要的行：使用 `limit` 限制返回的数据
        * 缓存高频查询的数据：使用缓存来防止每次都在数据库中查询
    2. 根据索引优化原则建立索引



#### 11.索引失效情况

1. 不符合最左匹配法则，或者索引使用在范围查询之后
2. 对索引使用聚合函数
3. 在索引上使用(!= 或者 <> 或者 is null 或者 is not null 或者 or ) 会使索引失效
4. 使用 like 以通配符开头（%字符串）时，使用覆盖索引可以解决





### 2.其他模块(锁, 事务等)

#### 1. 数据库事务的四大特性

* A（Atomic）原子性：事务包含的 sql 操作要么全部执行成功，要么全部失败并回滚，保证：undo log
* C（Consistency）一致性：事务应该要使数据库从一个一致状态，转变为另一个一致状态，不出现中间过程态，即满足完整性约束
* I（Isolation）隔离性：当事务并发执行时，也要保证事务之间互不干扰
* D（Durability）持久性：当一个事物提交之后，数据库状态永远的发生了改变，这个事物只要提交了，哪怕提交后宕机，他也确确实实的提交了。保证：redo log



#### 2. MySQL事务隔离级别

| 级别     | symbol           | 值   | 描述                                                         |
| -------- | ---------------- | ---- | ------------------------------------------------------------ |
| 读未提交 | READ-UNCOMMITTED | 0    | 存在脏读、不可重复读、幻读的问题                             |
| 读已提交 | READ-COMMITTED   | 1    | 解决脏读的问题，存在不可重复读、幻读的问题                   |
| 可重复读 | REPEATABLE-READ  | 2    | mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MVCC机制 实现可重复读 |
| 序列化   | SERIALIZABLE     | 3    | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

RR 级别可以通过手动对记录加锁的方法来消除幻读

当前读情况下 InnoDB 引擎中在 RR 中默认加了 `next-key locks` 锁来防止幻读, 理论上不会存在幻读

快照读情况下 MYSQL 通过 `mvcc` 来避免幻读



#### 2.1 事务隔离级别并发访问的问题

* 更新丢失-- 所有事务隔离级别都可避免【加锁】。
* 脏读        -- 指在一个事务处理过程里读取了另一个未提交的事务中的数据。RC 级别以上可解决
* 不可重复读-一个事务在多次读取数据时，另一个事务修改并提交，导致该事务读取的数据不一致。【读取数据不可靠】
* 幻读      -- 对于数据库中, 相同的区间查询, 插入和删除操作使得对相同的区间查询操作返回不同的结果.

#### 2.2 InnoDB 可重复读隔离级别下如何避免幻读

当前读：`select ... lock in share mode, select ... for update` 即加锁的增删改查语句

快照读：`select` 不加锁的非阻塞读，提升并发性能

**表象**：快照读（非租塞读）--伪 MVCC

**内在**：next-key 锁（record 锁 + gap（间隙）锁）

record 锁

锁定一个记录上的索引，而不是记录本身，如果表没有设置索引， InnoDB 会自动在主键上创建隐藏的聚簇索引。



间隙锁[锁住间隙]会使用在

* 非唯一索引
* 不走索引的当前读中
* 仅命中部分结果集，或者未命中结果集并且用到主键索引或者唯一索引的当前读中



#### 2.3. MVCC

MVCC(`Multiversion concurrency control`) 就是 同一份数据临时保留多版本的一种方式，进而实现并发控制



#### 3. 乐观锁和悲观锁

乐观锁和悲观锁是一种思想，不是一种具体的锁，具体的锁是这两种思想的实现

**乐观锁：**假设数据并发访问时一般不产生冲突，在数据提交更新时，才会正式对数据冲突进行检测，发生冲突则返回错误信息。

**悲观锁**：对外界数据修改持保守态度，具有强烈的独占和排他特性

**乐观锁实现方式**

1. CAS （compare and swap or set）

    当多个线程尝试使用 CAS 更新数据时，只有一个会成功，其余会失败

2. MVCC （多版本并发控制）

    为了解决 ABA 问题，可以采用多版本并发控制或者使用时间戳

**悲观锁实现方式**

1. 读锁（共享锁）
2. 写锁（排它锁）



**比较**

1. 乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。
2. 悲观锁依赖数据库锁，效率低。更新失败的概率比较低。

随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。



#### 4. MyISAM 与 InnoDB 关于锁方面的区别是什么

* MyISAM 默认使用表级锁, 不支持行级锁
* InnoDB 默认使用行级锁, 也支持表级锁

**表级锁**: 为一个表加上读锁或者写锁, 在锁未释放时, 要在读完后再写, 或者写完后再读。

​			**读锁（S）**： 也叫共享锁，可以在读锁再次进行读操作,无法进行写操作 

​			**写锁（X）**： 排斥锁，在写锁完成前无法进行其他读/写操作

InnoDB 是二段锁，即加锁和解锁分为两个步骤，使用时统一加锁，提交时统一解锁。

**行级锁**：为一行加上读锁或者写锁，在没有使用索引时，InnoDB 使用表级锁。

**意向锁**：事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。意向锁之间相互兼容（因为是意向锁）



**三级封锁协议**

1. 修改时必须加 X（写）锁；可以解决更新丢失问题
2. 读取时必须加 S（读）锁，读完后释放；可以解决脏读问题
3. 读取时必须加 S（读）锁，事务结束后释放；可以解决不可重复读问题



#### 5 MyISAM 和 InnoDB 使用场景

**MyISAM**：

* 频繁执行全表 count 语句
* 对数据进行增删改少，查询非常频繁
* 没有事务

**InnoDB**：

* 数据增删改查都相当频繁
* 可靠性要求比较高，需要使用事务



#### 6. 切分

1. **水平切分**

    将一个表中的记录拆分到多个结构相同的表中，他可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力

    * 可以解决缩表问题，可以保存在不同 MySQL 节点上，也可以通过 MySQL 数据分区技术把一张表挂在同个节点上
    * 不同数据表的切分规则并不一致，要根据实际业务来确定。且扩容比较麻烦，需要增加新的集群分片。正确做法是冷热数据分离，定期把分片中数据归档。

2. **垂直切分**

    将一张表按列分成多个表，可以将表的密集程度部署到不同的数据库中。

    * 可以降低单节点数据库的负载
    * 但是不能缩表（数据库数据量没有发生改变）

切分一般先水平切分再垂直切分，成本低且简单



#### 7. 主从复制和读写分离

**主从复制**

复制一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库



**作用**

1. 做数据热备：主服务器故障后，防止数据丢失
2. 有利于架构扩展，提高单个机器 I/O 性能
3. 读写分离，使数据库能支撑更大的并发



**主从复制过程**

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![master-slave](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/master-slave.png)



#### 8. 关系型数据库三大范式

1. 第一范式要求字段具有原子性，不可再分解，不能表中套表

2. 第二范式，非主键字段不能出现部分依赖主键（ 满足第一范式 ）

    1. 例如一张表主键为 （学号，课程号）
    2. 但是仅凭学号就能决定（姓名，年龄和地址），这就是部分依赖主键
    3. 解决方法：拆成两张表，一张表管一件事

    ![5](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/5.jpg)

3. 第三范式，非主键字段不能出现传递依赖。（且满足第二范式）

![6](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/6.jpg)





## Redis

Redis 应用

![16e30d2c5e17899c](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/16e30d2c5e17899c.png)

### 1. redis 的数据结构

1. String **字符串**

    `String`数据结构是简单的`key-value`类型，最常用的数据结构, 普通的 k/v 存储都可以归于此类, v 不仅是 string 还可以是数字。

    比如说记录微博数，粉丝数等。

    内部编码：`int`, `raw`, `embstr`， embstr 保存长度小于 44 字节的字符串

2. Hash **字典**

    不同于`string` 将整个对象序列化为`json`,  `Hash` 将对象的各个属性都存入 `Map` 中, 可以只读取/更新对象的某些属性, 像 `Mysql` 中的 `update`。

    可以用于存储用户信息和商品信息

    内部编码：HT（拉链法），ZipList（压缩表）

3. List **列表**

    应用为 `消息队列`, 可以利用 `Lists` 的 `PUSH` 操作, 将任务存在 `list` 中, 然后工作线程再用 `POP` 将任务取出进行执行。

    比如微博的关注列表，粉丝列表，消息列表等功能

    内部编码：QuickList（Ziplist【特殊编码（二进制）双向链表】 + 双向链表）

4. Set **集合**

    类似于 `List` 列表, 但是 `Set` 可以自动排重, 当存储一个列表数据但不希望出现重复数据时, 可以选择使用 `Set`

    可以

    应用差，并，交集操作例如应用有共同关注、共同粉丝、共同喜好等

    内部编码：HT， INTSET

5. Sorted Set **有序集合** ( Zsest )

    带有权重的 `Set`, 集合中的元素可以按权重进行有序排列

    用户列表，礼物排行榜，弹幕消息等应用

    内部编码：SkipList，ZipList

6. **消息订阅** ( Pub/Sub )

​        可以设定对某一个 `key` 值进行消息发布和消息订阅. `key` 值上进行了消息发布后, 所有订阅它的客户端都会收到相应的信息. 可以用作实时消息系统

7. **事务**( Transactions )

事务提交前, 不会执行任何指令, 只会把他们存到一个队列里, 事务提交时, 批量执行所有指令. 只保证事务里的操作会被连续独占的执行, 因为是单线程架构, 执行完之前不会执行别的客户端请求. 没有隔离级别概念, 不保证原子性, 只有执行全部命令的能力, 没有执行到一半回滚的能力.



### 2. 缓存雪崩以及如何解决

缓存同一时间内大面积失效，所有请求都落到数据库造成短时间内承受大量请求而崩掉。

**解决**：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。



### 3. 如何解决缓存穿透

缓存穿透是指恶意请求缓存中不存在的数据，所有请求都落到数据库造成短时间内承受大量请求而崩掉。

* 在接口层增加校验规则，用户鉴权，参数做校验，不合法的直接 return 掉
* 如果查询返回数据为空，扔把这个数据进行缓存，并设计一个很短的过期时间
* 将所有可能存在的数据存在一个足够大的位图中（使用 redis 的布隆过滤器）

### 4. 如何解决缓存击穿

缓存击穿为对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。在过期后，大并发访问热点数据导致服务器崩掉。

* 使用互斥锁，缓存失效先去获得锁，获得锁去访问数据库，否则休眠一段时间再重试
* 设置热点数据永不过期



### 5. Redis 挂掉了，请求全部走数据库怎么解决

事发前：实现 Redis 的高可用集群(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。

事发中：**设置本地缓存**(ehcache)+**限流**(hystrix)+**降级**，尽量避免我们的数据库挂掉(起码能保证我们的服务还是能正常工作的)

事发后：**redis持久化**（RDB+AOF），重启后自动从磁盘上加载数据，快速恢复缓存数据。



### 6. Redis 持久化机制：RDB 和 AOF

**RDB（快照持久化）**：

通过快照方式，即在指定时间间隔内将内存中的数据集快照写入磁盘。

在创建快照之后用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者重启服务器后恢复数据。RDB 是 Redis 默认的持久化方式。

缺点：RDB 需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大。



**AOF（append-only file）持久化**：

记录每次的写操作到日志上，重启时重放日志以重建数据。

缺点：AOF 每秒 fsync 一次指令硬盘，如果硬盘IO慢，会阻塞父进程；风险是会丢失 1 秒多的数据；在 Rewrite 过程中，主进程把指令存到 mem-buffer 中，最后写盘时会阻塞主进程。



可以 RDB + AOF混合持久化



子进程通过信号量来通知父进程



### 7. Redis 集群

Redis Sentinal 哨兵 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。

Redis Cluster  着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。

Redis Cluster 的数据分片不是一致性哈希实现而是使用哈希槽实现：一个集群包含 16384 个哈希槽，数据库中每个 Key 都属于这些哈希槽中的其中一个，集群使用公式 `CRC16(KEY) % 16384` 来计算 key 属于哪个哈希槽。

如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。
增加一个D节点的结果可能如下：

- 节点A覆盖 1365-5460
- 节点B覆盖 6827-10922
- 节点C覆盖 12288-16383
- 节点D覆盖 0-1364,5461-6826,10923-1228

如果要移出节点 A，那么集群需要将节点 A 中所有哈希槽移动到别的节点中。



**一致性哈希**

一致性 Hash 算法是将所有的哈希值构成一个环，其范围在 $0 ~ 2^{32}-1$ ，然后将各个节点散列到这个环上，可以用节点的 IP、hostname 这样的唯一性字段作为 Key 进行 `hash(key)`，散列之后如下：

![5cd1ba01ebc22](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/5cd1ba01ebc22-1598784231891.webp)

之后需要将数据定位到对应的节点上，使用同样的 `hash 函数` 将 Key 也映射到这个环上。

![5cd1ba05955b9](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/5cd1ba05955b9.webp)





#### 主从复制模型

如果为节点 A、B、C 节点中，B 节点下线了，那么集群将无法正常运行，因为 B 节点的哈希槽无其他节点代理，如果在创建集群时，创建了 B 节点的从节点 B1，那么 B 节点下线后， B1 就会代替下线的主节点 B

#### 一致性保证

Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：第一个原因是因为集群是用了异步复制. 写操作过程:

1. 客户端向主节点B写入一条命令.
2. 主节点B向客户端回复命令状态.
3. 主节点将写操作复制给他得从节点 B1, B2 和 B3



### 8. 如何解决 Redis 的并发竞争 Key 问题

多个系统同时对一个 key 进行操作，最后执行的顺序和我们期望的顺序不同，导致了结果的不同。

解决方案为分布式锁（zookeeper 和 redis 都可以实现分布式锁）。



### 9. Redis 分布式锁

先拿 setnx（set if not exist）来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

或者使用官方提供的 RedLock 分布式锁实现



**如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**

可以同时把 setnx 和 expire 合成一条指令来用的



### 10. 主从复制

Redis 可以通过 `slaveof <host> <port>` 命令或者通过配置 `slaveof` 选项，是当前服务器（slave）复制指定服务器（master）的内容。

**主从复制的好处：**

- 数据冗余，实现数据的热备份
- 故障恢复，避免单点故障带来的服务不可用
- 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量
- 高可用基础，是哨兵机制和集群实现的基础



**实现原理**

sync 命令（全量复制）

1. 主服务器创建快照文件，发给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕后，开始向从服务器发送存储在缓冲区的写命令
2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令
3. 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

psync (部分复制)

![11368879-02840e152c8261ee](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/11368879-02840e152c8261ee.webp)



### 11.Redis 和 Memcache 区别

* 数据类型：Memcache 只支持字符串， Redis 有 5 种不同类型
* 持久化：Memcache 不支持持久化，Redis 有 AOF RDB 两种持久化方式
* 分布式：Memcache 不支持分布式，Redis 支持分布式 Redis Cluster
* 内存管理机制：Redis 很久没用的数据会交换到磁盘，Memcache 将内存分割成特定长度块来存储数据，这样会浪费内存



### 12.布隆过滤器原理

布隆过滤器是一个位图（bit map)

当要映射一个值到布隆过滤器中，需要使用多个不同哈希函数生成多个哈希值，将其存入

![v2-a0ee721daf43f29dd42b7d441b79d227_r](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/v2-a0ee721daf43f29dd42b7d441b79d227_r.jpg)

此时再存入 “tencent”

![v2-c0c20d8e06308aae1578c16afdea3b6a_r](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/v2-c0c20d8e06308aae1578c16afdea3b6a_r.jpg)

此时 4 也被置 1 ，当存入的元素越来越多，被置 1 的也越来越多，所以也可能出现误判，查询到 “baidu”时只能说他可能存在，简单来说：

- 布隆过滤器说某个元素在，可能会被误判。
- 布隆过滤器说某个元素不在，那么一定不在。



### 13. Zset（Sorted set）底层原理

有序集合对象的编码可以是`ziplist`或者`skiplist`。同时满足以下条件时使用 ziplist 编码：

- 元素数量小于128个
- 所有 member 的长度都小于64字节

`ziplist`编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存 member，第二个保存 score。ziplist 内的集合元素按 score 从小到大排序，score 较小的排在表头位置。

![6302559-8e856eebe2fb78ed](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/6302559-8e856eebe2fb78ed.webp)

`skiplist`编码的有序集合底层是一个命名为`zset`的结构体，而一个 zset 结构同时包含一个字典和一个跳跃表。跳跃表按 score 从小到大保存所有集合元素。而字典则保存着从 member 到 score 的映射，这样就可以用 O(1) 的复杂度来查找 member 对应的 score 值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的 member 和 score，因此不会浪费额外的内存。



跳表 `skiplist` 基于并联的链表，也是链表的一种，在链表基础上增加了跳跃功能

![sorted_linked_list](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/sorted_linked_list.png)

这种链表，需要查找某个数据，就需要从头开始逐个进行比较来查找。

现在每两个相邻的节点再次增加一个指针，使指针指向下下个节点

![skip2node_linked_list](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/skip2node_linked_list.png)



每次查找只需进行比较当前，然后回退就行查找。



`skiplist` 正是受这种多层链表的想法的启发而设计出来的。

实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。

所以 `skiplist` 不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是每一层随机出一个层数（level）。

![skiplist_insertions](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/skiplist_insertions.png)





### 14. Redis 应用问题

**假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

使用 keys 指令可以扫出指定模式的 key 列表。



**如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？**

redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。



**使用过Redis做异步队列么，你是怎么用的？**

一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。



**可不可以不用sleep呢？**

list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。



**能不能生产一次消费多次呢**？

使用 pub/sub 主题订阅者模式，可以实现1:N的消息队列。



**pub/sub 有什么缺点？**

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。



**redis如何实现延时队列？**

使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。



### 15. Redis 快速原因

1. 完全基于内存，绝大部分请求时纯粹的内存操作，非常快速
2. 数据结构简单，对数据操作也简单
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路 I/O 复用模型，非阻塞 IO



### 16.Redis 缓存淘汰策略

| 策略            | 描述                                                 |
| --------------- | ---------------------------------------------------- |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰     |
| volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰           |
| allkeys-lru     | 从所有数据集中挑选最近最少使用的数据淘汰             |
| allkeys-random  | 从所有数据集中任意选择数据进行淘汰                   |
| noeviction      | 禁止驱逐数据                                         |



## MongoDB

### 1.MongoDB 优势有哪些

* 面向集合(`Collection`)和文档(`document`)的存储，以JSON格式的文档保存数据。
* 高性能，支持`Document`中嵌入`Document`减少了数据库系统上的I/O操作以及具有完整的索引支持，支持快速查询
* 高效的传统存储方式：支持二进制数据及大型对象
* 高可用性，数据复制集，MongoDB 数据库支持服务器之间的数据复制来提供自动故障转移（`automatic failover`）
* 高可扩展性，分片(`sharding`)将数据分布在多个数据中心,MongoDB支持基于分片键创建数据区域.
* 丰富的查询功能, 聚合管道(`Aggregation Pipeline`)、全文搜索(`Text Search`)以及地理空间查询(`Geospatial Queries`)
* 支持多个存储引擎,WiredTiger 存储引、In-Memory 存储引擎

### 2. 集合和文档与关系型数据库术语对比

* 集合（Collection）相当于表（Table），一个集合中有多个文档（Document）其中文档可以有多个不同的字段。

- 文档`Document`由key-value构成。文档`Document`是动态模式,这说明同一集合里的文档不需要有相同的字段和结构。类似于关系型数据库中table中的每一条记录。

### 3. MongoDB 使用场景

如果业务中存在大量复杂的事务逻辑操作，则不要用`MongoDB`数据库；在处理非结构化 / 半结构化的大数据使用`MongoDB`，操作的数据类型为动态时也使用`MongoDB`，比如：

- 内容管理系统，切面数据、日志记录

- 移动端`Apps`：`O2O`送快递骑手、快递商家的信息（包含位置信息）

- 数据管理，监控数据

    

### 4.MongoDB 的索引

MongoDB 使用 B 树数据结构作为索引

其索引类型有：

* **单字段索引**
* **复合索引**
* **多 key 索引**：索引字段为数组时，创建出来的为多 key 索引
* **哈希索引**：按照某个字段的 hash 值做索引，只能用于精确查询
* **地理位置索引**
* **文本索引**

### 5. 为什么 MongoDB 使用 B 树作为索引

- 作为非关系型的数据库，MongoDB 对于遍历数据的需求没有关系型数据库那么强，它追求的是读写单个记录的性能；
- 大多数的数据库面对的都是读多写少的场景，B 树与 LSM 树在该场景下有更大的优势；

而 B 树在查询单个数据记录所需要的的平均 I/O 次数比 B+ 树要少，使用 B 树的 MongoDB 在类似场景下查询会比 MySQL 快。



### 6. 为什么大容量数据库使用 MongoDB 而非 Redis

1. MongoDB 有丰富的数据表达、索引，支持丰富的查询语言；Redis 有丰富的数据类型但是较少的 IO
2. MongoDB 适合大数据量存储，依赖系统虚拟内存管理，采用镜像文件存储。Redis 也支持虚拟内存
3. MongoDB master-slave,replicaset（内部采用 paxos 选举算法，自动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。 redis，依赖客户端来实现分布式读写；
4. MongoDB 使用 binlog 方式支持持久化，Redis 则是 AOF 和 RDB
5. MongoDB 不支持事务，Redis 只保证事务中每个操作连续执行
6. MongoDB 内置数据分析功能