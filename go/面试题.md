# Go 语言相关

## 语法问题

### 1. Golang 如何创建一个 map

Map 是一种无序的键值对集合，可以通过 key 来快速检索数据。他是无序的，因为是使用 hash 表来实现的

```go
// 使用声明变量来创建
var map_var map[key_data_type]value_data_type
// 使用 make 函数来创建
map_var := make(map[key_data_type]value_data_type)
```

### 2. Golang 初始化顺序

 编译时, 根据 import 先后顺序执行, 先初始化常量再变量然后是 `init` 函数, 最后是 `main` 函数   

### 3. interface  和 nil 的区别

interface 底层有两个成员来实现, 一个是 type 一个是 data, 只有两个都为 `nil` 的时候才能判断为 `nil`. interface 判空: 

在知道类型可以使用, `ai, ok := i.(*int) ai == nil` 

不知道的话需要用反射来判断类型

 1. ```go
    func IsNil(i interface{}) bool {
        defer func() {
            recover()
        }()
        vi := reflect.ValueOf(i)
        return vi.IsNil()
    }
    
    // 不使用 defer recover
    func IsNil(i iterface{}) bool {
        vi := reflect.ValueOf(i)
        if vi.Kind() == reflect.Ptr {
            return vi.IsNil()
        }
        return false
    }
    ```



### 4. 并发安全的 Map : 加锁以及 sync.Map{} 的实现

| 实现方式    | 原理                                                         | 适用场景                                                     |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| map+Mutex   | 通过Mutex互斥锁来实现多个goroutine对map的串行化访问          | 读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景      |
| map+RWMutex | 通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高 | 同Mutex相比适用于读多写少的场景                              |
| sync.Map    | 底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化 | 读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现 |

### slice 和 array 的区别

1. `array` 是固定长度的数组，使用前需要确定数组的长度。`array` 是值类型, 如果将数组值付给另一个数组, 实际上是整个数组拷贝一份.
    1. `array` 作为函数传递,传递的是数组的拷贝, 而不是数组的指针
    2. `array` 长度也是 type 的一部分 `[10]int` 和 `[20]int` 是不同的
2. `slice` 是一个引用类型, 是一个动态的指向数组切片的指针
    1. 是不定长的, 总是指向底层数组 `array` 的数据结构
    2. 扩容机制和 `vector` 相似, 1024字节下每次`cap`增加一倍, 1024 以上增加 $\frac{1}{4}$  

 



## 协程问题

### 1. Golang 的 channel

Go 的 channel 来源于 CSP 模型（并发执行的实体组成，实体之间通过发送消息进行通信），Channel 是 Go 的一个核心类型，可以看成是一个管道，通过它并发核心单元可以进行发送或者接受数据进行通讯

```go
// 创建 channel
bufferChan := make(chan int, N) // 缓冲 channel
unBufferChan := make(chan int) //无缓冲 channel
```

如果没有 make 会出现 dead lock 错误：

```go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive (nil chan)]:
```

>   channel 分为无缓冲 channel 和有缓冲 channel。两者的区别如下：
>
>   *   无缓冲：发送和接收动作是同时发生的。如果没有 goroutine 读取 channel （<- channel），则发送者 (channel <-) 会一直阻塞。
>   *   缓冲：缓冲 channel 类似一个有容量的队列。当队列满的时候发送者会阻塞；当队列空的时候接收者会阻塞。



### 2. Go 的协程

​    协程为非抢占式调度。用户态模拟进程线程的切换的具体实现，并非 OS 内核提供的功能。有程序员主动控制协程之间的切换。

   golang 提供一种基于消息机制而非共享内存的通信模型。

   消息机制认为每个并发单元都是自包含的独立个体，并且拥有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元输入输出都是消息。



### 3. 创建多个 goroutine 在多核的情况下是如何分配的

首先多核分配多个 goroutine 分别进行执行，如果一个核 M 在执行完后，该核上下文 P 会定期检查全局 runqueue 中的 goroutine，如果有则加入到自己的 runqueue 中进行执行，如果没有，则从其他运行中的 P 中 runqueue 中偷取一半 goroutine 到自己队列中，如果未获取到则会停止这个 M。



### 4.并发协程如何优雅退出

1. for-range 结构退出:

    ```go
    go func(in <-chan int) {
        // Using for-range to exit goroutine
        // range has the ability to detect the close/end of a channel
        for x := range in {
            fmt.Printf("Process %d\n", x)
        }
    }(inCh)
    ```

2. for-select 结构退出

    1. 使用 ok 来退出

    ```go
    go func() {
    	// in for-select using ok to exit goroutine
    	for {
    		select {
    		case x, ok := <-in:
    			if !ok {
    				return
    			}
    			fmt.Printf("Process %d\n", x)
    			processedCnt++
    		case <-t.C:
    			fmt.Printf("Working, processedCnt = %d\n", processedCnt)
    		}
    	}
    }()
    ```

    2. 使用一个标记位 `stopCh` 来退出

        ```go
        func worker(stopCh <-chan struct{}) {
        	go func() {
        		defer fmt.Println("worker exit")
        		// Using stop channel explicit exit
        		for {
        			select {
        			case <-stopCh:
        				fmt.Println("Recv stop signal")
        				return
        			case <-t.C:
        				fmt.Println("Working .")
        			}
        		}
        	}()
        	return
        }
        ```

        



## 垃圾回收机制

Golang 使用的垃圾回收机制是三色标记法配合写屏障和辅助 GC，三色标记法是标记-清除法的一种增强版本。





# Docker

## 1. docker 如何映射端口

```dockerfile
docker run -d \
-p 8080:80 # 指定端口映射，将容器80端口映射到主机8080端口
```

  如果不指定端口映射参数，在容器外部无法通过网络来访问容器内的网络应用和服务的。

 

docker 中包含 bridge, host, none 三种网络，还有 container 第四种网络。其中 bridge 是默认网络 none 是无网络， host是宿主机网络， container 是与指定容器共享网络。



bridge 是 通过 iptables 将流量打到 docker0 的子网上的， iptables将来自 8080 端口的流量打到 80 端口上。



## 2. 容器(docker) 和镜像的区别

容器 = 镜像 + 可读层. 这并非为运行态容器. 

运行态容器则是在容器的基础上加上隔离的进程空间 ( 文件系统隔离 )

# 项目相关

## Go 项目相关

### 1. 实现 `sql` 连接池

1. 初始化 DB : `db, err := sql.Open("mysql", "xxxx")`
    1. `sql.Open()`是取出对应的db，这时mysql还没有建立连接，只是初始化了一个`sql.DB`结构，这是非常重要的一个结构，所有相关的数据都保存在此结构中；Open同时启动了一个`connectionOpener`协程
2. 获取链接: `rows, err := db.Query("select * from test")` 
    1. 只有等使用时才会真正建立连接

### 2. 控制查询超时

1. `select` + `time.After`

    1. 代码实现

        ```go
        ch := make(chan string)
        
        go func() {
            time.Sleep(time.Second * 2)
        
            ch <- "result"
        }()
        
        select {
            case res := <-ch:
            fmt.Println(res)
            case <-time.After(time.Second * 1):
            fmt.Println("timeout")
        }
        ```

2. `context` 超时控制

    1.  `context.WithTimeout`  设置超时时间



## JWT （JSON Web Token）

该 token 被设计为紧凑且安全的，特别适用于单点登录场景（SSO）



JWT 由 `Header` `Payload` `Signature` 三部分组成。

>1.  Header：通常由两部分组成，令牌类型和签名所使用的算法
>2.  Payload(有效载荷)：包含 claims，通常是用户数据结构与其他数据的声明
>3.  Signature ：签名用于验证消息在整个过程中没有更改，并且对于使用私钥进行签名的令牌，它还可以验证 JWT 的发送者是他所说的真实身份

## Git 相关

### 1. git 如何切换分支

创建分支，删除分支，重命名分支，列出所有分支：`git branch`

切换分支 `git checkout`

合并分支 `git merge`

### 2. git 如何和两个远程仓库连接

  

```bash
git remote add 代号 仓库地址

# 推到仓库
git push 代称 分支
```



## 如何应对高并发

1）客户端发出请求层面：

*   尽量减少请求数量：
    *   尽量利用浏览器缓存功能，减少访问服务端
    *   考虑使用压缩传输的功能，减少网络流量
    *   使用异步请求，分批获取数据
*   尽量减少对服务端资源的不必要耗费
    *   重复使用某些资源

2）从服务端看

*   增加资源供给
    *   更大的网络带宽
    *   配置更好的服务器
    *   高性能数据库
*   请求分流
    *   集群
    *   分布式系统架构
*   应用优化
    *   更高效的编程语言
    *   优化处理业务逻辑的算法
    *   优化访问数据库的 SQL



# 计算机网络

## TCP/IP

### TCP 的可靠性





# 操作系统

## 进程和线程

定义: 进程是资源分配的基本单位(最小资源管理单位)

​		  线程是独立调度的基本单位(最小执行单位)

区别: 

1. 进程之间不能共享资源,线程可以共享所在进程的地址空间和其他资源
2. 进程有自己独立的地址空间, 线程没有,线程必须依赖进程而存在

### 进程调度算法

#### ①. 批处理系统

1. 先来先服务
2. 短作业优先
3. 最短剩余时间优先

#### ②. 交互式系统

1. 时间片轮转
2. 优先级调度
3. 多级反馈队列

### 进程通信方法

1. 管道 ( 半双工通信[父子进程或兄弟进程] )
2. 命名管道 ( 去除管道的父子进程限制 )
3. 消息队列 ( 独立读写进程存在,避免了 FIFO 中同步管道的打开和关闭时坑你产生的困难 )
4. 信号量
5. 共享存储



## Linux

### 1. 文件查看命令

`more` – 传统且基础的分页阅读工具，仅支持向下翻页和有限次数的向上翻页。

`less` – 比 `more` 功能丰富，支持向下翻页和向上翻页，也支持文本搜索。在打开大文件的时候，比 `vi` 这类文本编辑器启动得更快。

`most` – 在上述两个工具功能的基础上，还加入了同时打开多个文件、同时锁定或滚动多个屏幕、分屏等等大量功能。



# 数据库

## MySQL

### 1. 索引是什么? 具体是什么数据结构?

1. 索引是一种数据结构, 能够帮助我们快速检索数据库中的数据
2. MySQL 主要有两种数据结构: Hash 索引和  B+ Tree 索引, InnoDB 引擎,默认使用 B+Tree

### 2. B + 树和 Hash 索引的比较有什么优缺点?

1. 哈希索引只适合等值查询, 但是无法进行范围查询
2. 哈希索引无法进行排序
3. 哈希索引不支持多列联合索引的最左匹配规则
4. 如果有大量重复值存在, 哈希索引效率会很低, 因为存在哈希碰撞问题

### 3. B+ 树是什么?

​	B + 树一种多路平衡查找树, 结构如下:

![img](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1383122-20200510121023476-1149349624.png)

​	其叶子节点是一个双向循环链表, 在范围查询中, 只用找到一个数据, 就可以直接返回剩余的数据. 且数据仅存在于叶子节点, 其扩充规律如下:

![img](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1383122-20200510121103015-569225302.png)

B 树是父节点也存在数据的 B+ 树, 且叶子结点不存在指针.

### 4. B + Tree **的叶子节点都可以存什么东西**?  聚簇索引和非聚簇索引

InnoDB 的可能存储整行数据, 也可能 是主键的值 . 

聚簇索引和非聚簇索引的区别是: **叶子节点是否存储整行记录**.

InnoDB 主要使用聚簇索引, MyISAM 主键索引和二级索引都是使用非聚簇索引. 

聚簇索引, 表数据和主键一起存储的, 非聚簇索引是分开存储的. 

**聚簇索引的优点:**

```
1. 取出范围数据时, 其查询速度比非聚簇索引快
```
 	2. 查找目标数据时理论上比非聚簇索引要快, 因为非聚簇索引定位到对应主键时还要多一次目标记录寻址, 即多一次 I/O
 	3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

**聚簇索引的缺点**

1. 插入速度严重依赖于插入顺序
2. 更新主键代价很高, 因为会导致被更新的行移动
3. 二次索引访问需要两次索引查找, 第一次找到主键值, 第二次根据主键找到数据
4. 插入速度比非聚簇索引慢很多

### 5. 非聚簇索引查询时一定会查询多次吗?

不一定, 可以通过覆盖索引可以只查询一次. *覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。*

### 6. 最左前缀匹配

创建联合索引的适合会将识别度最高的字段放到最前面. 因为 MySQL 索引查询会遵循最左前缀匹配原则, 即最左优先. 



### 7. 幻读

对于数据库中, 相同的区间查询, 插入和删除操作使得对相同的区间查询操作返回不同的结果.

MySQL ( InnoDB ) 中的 RR 级别引入了间隙锁来解决幻读问题



### 8. MySQL事务隔离级别

| 级别     | symbol           | 值   | 描述                                                         |
| -------- | ---------------- | ---- | ------------------------------------------------------------ |
| 读未提交 | READ-UNCOMMITTED | 0    | 存在脏读、不可重复读、幻读的问题                             |
| 读已提交 | READ-COMMITTED   | 1    | 解决脏读的问题，存在不可重复读、幻读的问题                   |
| 可重复读 | REPEATABLE-READ  | 2    | mysql 默认级别，解决脏读、不可重复读的问题，存在幻读的问题。使用 MMVC机制 实现可重复读 |
| 序列化   | SERIALIZABLE     | 3    | 解决脏读、不可重复读、幻读，可保证事务安全，但完全串行执行，性能最低 |

RR 级别可以通过手动对记录加锁的方法来消除幻读

当前读情况下 InnoDB 引擎中在 RR 中默认加了 `next-key locks` 锁来防止幻读, 理论上不会存在幻读

快照读情况下 MYSQL 通过 `mvcc` 来避免幻读



## Redis

### 1. redis 的数据结构

1. String **字符串**

    最常用的数据结构, 普通的 k/v 存储都可以归于此类, v 不仅是 string 还可以是数字

2. Hash **字典**

    不同于`string` 将整个对象序列化为`json`,  `Hash` 将对象的各个属性都存入 `Map` 中, 可以只读取/更新对象的某些属性, 像 `Mysql` 中的 `update`

3. List **列表**

    应用为 `消息队列`, 可以利用 `Lists` 的 `PUSH` 操作, 将任务存在 `list` 中, 然后工作线程再用 `POP` 将任务取出进行执行

4. Set **集合**

    类似于 `List` 列表, 但是 `Set` 可以自动排重, 当存储一个列表数据但不希望出现重复数据时, 可以选择使用 `Set`

5. Sorted Set **有序集合** ( Zest )

    带有权重的 `Set`, 集合中的元素可以按权重进行有序排列

6. **消息订阅** ( Pub/Sub )

​        可以设定对某一个 `key` 值进行消息发布和消息订阅. `key` 值上进行了消息发布后, 所有订阅它的客户端都会收到相应的信息. 可以用作实时消息系统

7. **事务**( Transactions )

​      事务提交前, 不会执行任何指令, 只会把他们存到一个队列里, 事务提交时, 批量执行所有指令. 只保证事务里的操作会被连续独占的执行, 因为是单线程架构, 执行完之前不会执行别的客户端请求. 没有隔离级别概念, 不保证原子性, 只有执行全部命令的能力, 没有执行到一半回滚的能力.





