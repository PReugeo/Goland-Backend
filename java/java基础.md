# Java基础

## 面向对象

- 面向对象特征

- - 封装(encapsulation)
    - 继承(inheritance)
    - 多态(polymorphism)

- 类：是一组相关的属性和行为的集合

- 对象：是该类事物的具体体现

### 封装

1.封装:

是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

**好处：**

隐藏实现细节，提供公共的访问方式

提高了代码的复用性

提高安全性。

**封装原则：**

将不需要对外提供的内容都隐藏起来。

把属性隐藏，提供公共方法对其访问

 

**private**

只能在本类中使用

**this:**

代表所在类的对象引用

使用: 局部变量隐藏成员变量

**static**

特点:

1.随着类的加载而加载

2.优先于对象存在

3.被类的所有对象共享

这也是我们判断是否使用静态关键字的条件

4.可以通过类名调用

**注意事项:**

1.在静态方法中是没有this关键字的

2.静态方法只能访问静态的成员变量和静态的成员方法

**执行顺序**

静态代码块>构造代码块>构造方法

### 继承

**继承概述:**

- 1.多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
- 2.通过extends关键字可以实现类与类的继承

class 子类名 extends 父类名 {} 

- 3.单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。

 

**继承优点:**

1.提高代码复用性

2.提高代码可维护性

3.让类与类产生关系,是多态的前提

 

**继承弊端:**

1.类的耦合性很强

2.打破了封装性

 

**super关键字:**

this代表本类对应的引用.

super代表父类存储空间标识(父类引用)

 

**final关键字:**

修饰类时:类不能被继承

修饰变量时: 变量变成了常量,只能被复制一次

修饰方法:方法不能被重写

### **多态**

**多态概述:**

某一个事物,在不同时刻表现出来的不同状态

 

**前提与体现:**

1. 有继承
2. 有方法重写
3. 有父类引用指向子类对象

 

**好处:**

1.提高程序维护性(继承)

2.提高程序扩展性(多态)

 

**弊端:**

1.不能访问子类特有功能

解决办法:

创建子类对象

 

多态的成员访问特点：

​    A:成员变量

​     编译看左边，运行看左边。

  B:成员方法

​     编译看左边，运行看右边。

  为什么呢?

​     因为成员方法有重写，而变量没有。

  C:静态方法

​     编译看左边，运行看左边。

​     静态方法其实没有重写这一说。因为它是跟类相关。

 

多态表现形式:

1. 具体类多态
2. 抽象类多态
3. 接口多态

### 抽象类

有些时候，我们对事物不能用具体的东西来描述，这个时候就应该把事物定义为抽象类。

**特点**

1. A:抽象类或者抽象方法必须用abstract修饰
2. B:抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
3. C:抽象类不能实例化
    1. 可以按照多态的方式实例化。
4. D:抽象类的子类
    1. a:要么是抽象类
    2. b:要么重写抽象类中的所有抽象方法
5. 有构造函数
    1. 用于子类访问父类数据的初始化

### 内部类

1. 把类A定义在类B内部，类A就被称为内部类
2. 访问特点：
    1. A:内部类可以直接访问外部类的成员，包括私有
    2. B:外部类要想访问内部类的成员，必须创建对象

3. 内部类的分类：

    A:成员内部类

    B:局部内部类

4. 成员内部类

    A:private

    B:static

 

面试题：

num

this.num

Outer.this.num

(5)局部内部类

A:面试题

局部内部类访问局部变量，必须加final修饰

 

```txt
原因:
 因为局部变量会随着方法的调用完毕而消失，
 这个时候，局部对象并没有立马从堆内存中消失，
   还要使用那个变量。为了让数据还能继续被使用，
   就用fianl修饰，这样，在堆内存里面存储的其实是一个常量值。
```

 

(6)匿名内部类(掌握) 

A:没有名字的内部类

B:前提

存在一个类或者接口

C:格式

```java
new 类名或者接口名() {

重写方法();

};
```



本质：是一个匿名子类对象

 

(7)开发中如何使用

不用在定义一个新的类了。直接通过匿名内部类的格式就可以搞定

 ```java
interface Person {

	public abstract void show();

}

 
class PersonDemo {

	public void method(Person p) {

		p.show();

	}

}


PersonDemo pd = new PersonDemo();

pd.method(new Person(){

	public void show(){...}

});
 ```

### 接口

#### 接口的特点：

A:定义接口用关键字interface

格式是：interface 接口名 {}

B:类实现接口用关键字implements 

格式是：class 类名 implements 接口名 {}

C:接口不能实例化

D:接口的子类

a:要么是抽象类

b:要么重写接口中的所有方法



#### 接口的成员特点

A:成员变量

只能是常量。

默认修饰符：public static final

B:成员方法

只能是抽象方法。

默认修饰符：public abstract 

推荐：

建议自己写接口的时候，把默认修饰符加上。

#### 抽象类和接口的区别?

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。



#### JDK8新接口

接口可以定义default, static(由接口名直接使用)方法

 ```java
interface Test {

​    public default void fun(){

​        xxxxx

​     }

​     

​     public static void fun2() {

​         xxxxx

​     }

}
 ```



### Object类

(1)是类层次结构的根类，所有类都直接或者间接的继承自该类

(2)构造方法：

只有一个无参构造方法。

protected Object clone():克隆对象

对象要想能够使用克隆方法，对象所属的类必须实现克隆接口。

1. 浅拷贝:

创建一个新对象,复制目标对象的值和 孩子方法(指向同一对象)[引用传递]

2. 深拷贝:

创建一个新对象,复制目标对象的值和 孩子方法(不指向同一对象)[值传递]

(4)面试题：(掌握)

==和equals()的区别?

A:==

基本类型：比较的是基本类型的值是否相同

引用类型：比较的是引用类型的地址值是否相同

B:equals()

只能比较引用类型，默认比较的是对象的地址值是否相同。

但是，可能被重写，一定要根据实际的情况来看。



## Java集合框架

### Collection集合体系结构

Collection

​	|--List(元素有序，可重复)

​		|--ArrayList

​				底层数据结构是数组，查询快,增删慢

​				线程不安全,效率高

​		|--Vector

​				底层数据结构是数组，查询快,增删慢

​				线程安全,效率低

​		|--LinkedList

​				底层数据结构是链表，查询慢,增删快

​				线程不安全,效率高

​	|--Set(元素无序，唯一)

​		|--HashSet

​			底层数据结构是哈希表。

​			保证元素的唯一性?

​					依赖两个方法hashCode()和equals()。

​			|--LinkedHashSet

​					底层数据结构是哈希表和链表

​					由哈希表保证元素唯一

​					由链表保证元素有序

​		|--TreeSet

​					底层数据结构是二叉树(红黑树)

​					保证元素的唯一性?

​							根据比较的返回值是否是0

​					保证元素的排序?

​							自然排序

​							比较器排序

 

### Map体系结构

Map

​     |--HashMap 键无序,唯一

​       	|--LinkedHashMap 键有序,唯一

​     |--Hashtable

​     |--TreeMap

 

 

### 针对Collection，你准备使用谁?

元素唯一吗?

​	是：Set

​		要排序吗?

​			是：TreeSet

​			否：HashSet

 		不知道，就用HashSet

​	否：List

​			要安全吗?

​					要：Vector(其实也不用，有更好的方式，后面讲)

​					不要：ArrayList或者LinkedList

​							查询多：ArrayList

​							增删多：LinkedList

 

​			不知道，就用ArrayList 

不知道，就用ArrayList

 

### 面试题：

 **1:HashMap 和 Hashtable 的区别?**

 A:HashMap 是线程不安全的，效率高。允许使用 null 值和 null 键。

 B:Hashtable 是线程安全的，效率低。不允许使用 null 值和 null 键。

****

 **2:List,Set,Map等接口是否都继承自Map接口**

 List,Set 都继承自 Collection 接口。

 Map本身就是顶层接口

 

 

### 集合中的数据结构问题

ArrayXxx:底层数据结构是数组，查询快，增删慢

LinkedXxx:底层数据结构是链表，查询慢，增删快

HashXxx:底层数据结构是哈希表。依赖两个方法hashCode()和equals()，根据情况选择是否自动重写

TreeXxx:底层数据结构是二叉树。有两种方案：自然排序，比较器排序。

面试题：数组和集合的区别?

   A:集合长度可变；集合只能存储引用数据类型；集合可以存储不同数据类型的元素

   B:数组长度固定；数组可以存储引用数据类型，也可以存储基本数据类型；数组存储的是同一种数据类型的元t素

