# 选择排序

从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。

选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

![img](%E6%8E%92%E5%BA%8F.assets/bc6be2d0-ed5e-4def-89e5-3ada9afa811a.gif)

```go
func SelectionSort(nums []int) []int {
	if len(nums) == 0 {
		return nums
	}

	for i := 0; i < len(nums); i ++ {
		minI := i
		for j := i+1; j < len(nums); j ++ {
			if nums[j] < nums[minI] {
				minI = j
			}
		}
		nums[i], nums[minI] = nums[minI], nums[i]
	}
	return nums
}

```



# 冒泡排序

从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。

在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。

![img](%E6%8E%92%E5%BA%8F.assets/0f8d178b-52d8-491b-9dfd-41e05a952578.gif)

```go
func BubbleSort(nums []int) []int {
	isSorted := false
	for i := len(nums) - 1; i > 0 && !isSorted; i-- {
		isSorted = true
		for j := 0; j < i; j++ {
			if nums[j+1] < nums[j] {
				isSorted = false
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
	return nums
}
```



# 插入排序

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。

插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。

- 平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；
- 最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

![img](%E6%8E%92%E5%BA%8F.assets/35253fa4-f60a-4e3b-aaec-8fc835aabdac.gif)

```go
func InsertSort(nums []int) []int {
	for i := 1; i < len(nums); i++ {
		for j := i; j > 0; j-- {
			if nums[j] > nums[j-1] {
				break
			}
			nums[j-1], nums[j] = nums[j], nums[j-1]
		}
	}
	return nums
}
```



# 希尔排序

希尔排序是插入排序的改进版本。

希尔排序通过交换不相邻的元素，每次将逆序数量减少大于 1。希尔排序是非稳定排序（ 即排序后具有相同值的元素的位置可能不一样 ）。

希尔排序通过使用插入排序对间隔 h 的序列进行排序。通过不断减少 h，最后令 h = 1，就可以使整个数组有序。

代码：

```java
/**
 * 希尔排序
 * @author Administrator
 */
func ShellSort(nums []int) []int {
	gap := 1
	for gap <= len(nums) / 3 {
		gap = 3 * gap + 1
	}
	
	for gap >= 1 {
		for i := gap; i < len(nums); i++ {
			for j := i; j >= gap; j -= gap {
				if nums[j] < nums[j - gap] {
					nums[j], nums[j - gap] = nums[j - gap], nums[j]
				}
			}
		}
		gap /= 3
	}
	return nums
}
```

时间复杂度：$O(n^{(1.3-2)})$ ，空间复杂度：$O(1)$

# 归并排序

归并排序是利用归并的思想实现的排序算法，算法采用经典的分支策略（分治法就是将问题分解为小问题然后进行递归求解，而治的阶段就是将分的阶段得到的各答案修补在一起）。

归并排序是稳定排序。

![img](.\数据结构.assets\分治法.png)

代码：

```java
/**
 * @author EugeoY
 */
func MergeSort(nums []int) []int {
	return mergeSort(nums)
}

func mergeSort(nums []int) []int {
	if len(nums) <= 1 {
		return nums
	}
	mid := len(nums) / 2
	left := mergeSort(nums[:mid])
	right := mergeSort(nums[mid:])
	return merge(left, right)
}

func merge(left, right []int) (res []int) {
	l := 0
	r := 0
	for l < len(left) && r < len(right) {
		if left[l] < right[r] {
			res = append(res, left[l])
			l++
		} else {
			res = append(res, right[r])
			r++
		}
	}
	res = append(res, left[l:]...)
	res = append(res, right[r:]...)
	return
}
```

时间复杂度为 $O(n \log n)$ ， 空间复杂度 $O(N)$



# 快速排序

快速排序思想：通过一趟排序把要排序的数据分割成两部分，其中一部分所有数据都比另一部分的所有数据小，再用这种方法对两部分数据分别进行快速排序，整个过程 可以递归进行，使整个数据变成有序序列。

是典型的分支思想。

**算法步骤**

1. 从待排序数组中选取一个“ 基准 ” 元素
2. 重新排序数组，所有比基准小的摆在基准前面，大的放后面，在这之后该基准就处于数组中间位置，这个操作称为分区( partition )
3. 递归把小于基准的子数组和大于基准的大数组排序

**代码实现（ Go ）**

```java
// QuickSort 最好 O(nlogn) 最差 O(n^2) 平均 O(nlogn)
func QuickSort(nums []int) []int {
	rand.Seed(time.Now().UnixNano())
	quickSort(nums, 0, len(nums)-1)
	return nums
}

func quickSort(nums []int, start, end int) {
	if end > start {
		pos := randPartition(start, end, nums)
		quickSort(nums, start, pos-1)
		quickSort(nums, pos+1, end)
	}
}

func randPartition(start, end int, nums []int) int {
	i := rand.Int()%(end-start+1) + start
	nums[i], nums[start] = nums[start], nums[i]
	return partition(start, end, nums)
}
// 以 end 为基准的 partition
//func partition(start, end int, nums []int) int {
//	i := start 
//	pos := nums[end]
//	for j := start; j <= end; j++ {
//		if nums[j] < pos {
//			nums[i], nums[j] = nums[j], nums[i]
//			i++
//		}
//	}
//	nums[end], nums[i] = nums[i], nums[end]
//	return i
//}
// 以 start 为基准的 partition
func partition(start, end int, nums []int) int {
	i := start 
	pos := nums[start]
	for j := start+1; j <= end; j++ {
		if nums[j] < pos {
			i++
			nums[i], nums[j] = nums[j], nums[i]
		}
	}
	nums[start], nums[i] = nums[i], nums[start]
	return i
}
// 第二种 partition 方法
func partition2(start, end int, nums []int) int {
	pos, i, j := nums[start], start, end

	for i < j {
		for i < j && nums[j] >= pos {
			j--
		}
		for i < j && nums[i] <= pos {
			i++
		}
		if i > j {
			break
		}
		nums[i], nums[j] = nums[j], nums[i]
	}
	nums[i], nums[start] = nums[start], nums[i]
	return i
}
```

快速排序是原地排序，不需要辅助数组，但是递归调通需要辅助栈。

平均算法复杂度$O(n \log n)$ ，最坏情况是第一次从最小元素切分，第二次从第二小元素切分，最坏需要比较 $\frac{N^2}{2}$ 次，所以为了防止数组开始有序，在快速排序前需要随机打乱数组。

##  快排的改进

### 3.1 切换到插入排序

因为快速排序在==小数组==中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

### 3.2 三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。

### 3.3 三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。

```go
func qsort(nums []int) []int {
	sort(0, len(nums)-1, nums)
	return nums
}

func sort(start, end int, nums []int) {
	if start > end {
		return
	}
	l, i, r := start, start + 1, end
	pos := nums[l]
	for i <= r {
		cmp := nums[i] - pos;
		if cmp < 0 {
			nums[l], nums[i] = nums[i], nums[l]
			l++
			i++
		} else if cmp > 0 {
			nums[i], nums[r] = nums[r], nums[i]
			r--
		} else {
			i++
		}
	}
    // [l, r] 之间已经有序
	sort(start, l-1, nums)
	sort(r+1, end, nums)
}
```



# 堆排序

## 1. 堆

堆中某个节点的值总是大于其子节点的值，并且堆是一颗完全二叉树。

推可以用数组表示，这是因为堆是完全二叉树。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。

 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png) 

## 2. 堆排序

将最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，就可以得到一个从头到尾的递减序列。

1. 构建堆（ 将无序数组构建成一个小顶堆 ）
2. 将最大元素和最后一个元素交换位置，并使其下沉。

```go
func HeapSort(nums []int) []int {
	lens := len(nums)
	for i := lens / 2; i >= 0; i-- {
		sink(nums, i, lens)
	}

	for i := lens - 1; i >= 0; i-- {
		nums[0], nums[i] = nums[i], nums[0]
		lens--
		sink(nums, 0, lens)
	}
	return nums
}

func sink(nums []int, i, length int) {
	max := i
	l, r := 2 * i + 1, 2 * i + 2
	if l < length && nums[l] > nums[max] {
		max = l
	}
	if r < length && nums[r] > nums[max] {
		max = r
	}
	if max != i {
		nums[i], nums[max] = nums[max], nums[i]
		sink(nums, max, length)
	}
}
```

## 4. 分析

一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

堆排序，因为要对 N 个节点进行下沉操作，因此复杂度为 $N \log{N}$ 。

堆排序为原地排序，没有利用额外空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。

# 小结

# 排序算法的比较

| 算法             | 稳定性 | 时间复杂度                   | 空间复杂度 | 备注                     |
| ---------------- | ------ | ---------------------------- | ---------- | ------------------------ |
| 选择排序         | ×      | N2                           | 1          |                          |
| 冒泡排序         | √      | N2                           | 1          |                          |
| 插入排序         | √      | N ~ N2                       | 1          | 时间复杂度和初始顺序有关 |
| 希尔排序         | ×      | N 的若干倍乘于递增序列的长度 | 1          | 改进版插入排序           |
| 快速排序         | ×      | NlogN                        | logN       |                          |
| 三向切分快速排序 | ×      | N ~ NlogN                    | logN       | 适用于有大量重复主键     |
| 归并排序         | √      | NlogN                        | N          |                          |
| 堆排序           | ×      | NlogN                        | 1          | 无法利用局部性原理       |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。



参考

 https://www.cnblogs.com/chengxiao/p/6194356.html

[https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F?id=%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f](https://cyc2018.github.io/CS-Notes/#/notes/算法 - 排序?id=选择排序)