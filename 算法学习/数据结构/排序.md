# 1. 希尔排序

希尔排序是插入排序的改进版本。

希尔排序通过交换不相邻的元素，每次将逆序数量减少大于 1。希尔排序是非稳定排序（ 即排序后具有相同值的元素的位置可能不一样 ）。

希尔排序通过使用插入排序对间隔 h 的序列进行排序。通过不断减少 h，最后令 h = 1，就可以使整个数组有序。

代码：

```java
/**
 * 希尔排序
 * @author Administrator
 */
public class ShellSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		int n = nums.length;
		int h = 1;
		int s = 3;

		while (h < n / s) {
			h = s * h - 1;  //设置 h 初值
		}

		while (h >= 1) {
			for (int i = h; i < n; i++) {
				for (int j = i; j >= h && less(nums[j], nums[j - h]); j -= h) {
					swap(nums, j, j - h);
				}
			}
			h /= s;
		}
	}

	public static void main(String[] args) {
		ShellSortApp<Integer> sortApp = new ShellSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
```

时间复杂度：$O(n^{(1.3-2)})$ ，空间复杂度：$O(1)$

# 2. 归并排序

归并排序是利用归并的思想实现的排序算法，算法采用经典的分支策略（分治法就是将问题分解为小问题然后进行递归求解，而治的阶段就是将分的阶段得到的各答案修补在一起）。

归并排序是稳定排序。

![img](.\数据结构.assets\分治法.png)

代码：

```java
/**
 * @author EugeoY
 */
public class MergeSortApp<T extends Comparable<T>> extends BaseSort<T> {
	protected T[] aux;

	protected void merge(T[] nums, int l, int m, int h) {
		//左序列指针
		int i = l;
		//右序列指针
		int j = m + 1;

		if (h + 1 - l >= 0) {
			//复制数据到辅助数组
			System.arraycopy(nums, l, aux, l, h + 1 - l);
		}

		for (int k = l; k <= h; k++) {
			if (i > m) {
				nums[k] = aux[j++];

			} else if (j > h) {
				nums[k] = aux[i++];

			} else if (aux[i].compareTo(aux[j]) <= 0) {
				//保证稳定性
				nums[k] = aux[i++];
			} else {
				nums[k] = aux[j++];
			}
		}

	}


	@Override
	public void sort(T[] nums) {
		aux = (T[]) new Comparable[nums.length];

		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

        //将数组拆分为一半后进行合并
		int mid = l + (h - l) / 2;
		sort(nums, l, mid);
		sort(nums, mid + 1, h);
		merge(nums, l, mid, h);
	}

	public static void main(String[] args) {
		MergeSortApp<Integer> sortApp = new MergeSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
}
```



时间复杂度为 $O(n \log n)$ 



# 3. 快速排序

快速排序思想：通过一趟排序把要排序的数据分割成两部分，其中一部分所有数据都比另一部分的所有数据小，再用这种方法对两部分数据分别进行快速排序，整个过程 可以递归进行，使整个数据变成有序序列。

是典型的分支思想。

**算法步骤**

1. 从待排序数组中选取一个“ 基准 ” 元素
2. 重新排序数组，所有比基准小的摆在基准前面，大的放后面，在这之后该基准就处于数组中间位置，这个操作称为分区( partition )
3. 递归把小于基准的子数组和大于基准的大数组排序

**代码实现（ Java ）**

```java
public class QuickSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		shuffle(nums);
		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

		int j = partition(nums, l, h);
		sort(nums, l, j - 1);
		sort(nums, j + 1, h);
	}

    //随机打乱数组顺序，使基准元素的元素随机
	private void shuffle(T[] nums) {
		List<Comparable> list = Arrays.asList(nums);
		Collections.shuffle(list);
		list.toArray(nums);
	}
    
	//分区操作
	private int partition(T[] nums, int l, int h) {
		int i = l, j = h + 1;
		T v = nums[l];
		while (true) {
			while (less(nums[++i], v) && i != h);
			while (less(v, nums[--j]) && j != l);
			if (i >= j) {
				break;
			}
			swap(nums, i, j);
		}
		swap(nums, l, j);
		return j;
	}

	public static void main(String[] args) {
		QuickSortApp<Integer> sortApp = new QuickSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23,56456,45642,121,5,2,48426,2154,65};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
}
```

快速排序是原地排序，不需要辅助数组，但是递归调通需要辅助栈。

平均算法复杂度$O(n \log n)$ ，最坏情况是第一次从最小元素切分，第二次从第二小元素切分，最坏需要比较 $\frac{N^2}{2}$ 次，所以为了反之数组开始有序，在快速排序前需要随机打乱数组。

##  快排的改进

### 3.1 切换到插入排序

因为快速排序在==小数组==中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

### 3.2 三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。

### 3.3 三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。

```java
package com.eugeo.sort;

public class ThreeWayQuickSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

		int lt = l, i = l + 1, gt = h;
		T v = nums[l];
		while (i <= gt) {
			int cmp = nums[i].compareTo(v);
			if (cmp < 0) {
				swap(nums, lt++, i++);
			}  else if (cmp > 0) {
				swap(nums, i, gt--);
			} else {
				i++;
			}
		}
		sort(nums, l, lt - 1);
		sort(nums, gt + 1, h);
	}
}
```

## 基于切分的快速选择算法

快排的切分方法，会返回一个整数 j 使得 $a[l\dots j-1] \leq a[j]$ 且 $a[j+1\dots h]\geq a[j]$ 此时， a[j] 就是数组的第 j 大的元素。

利用这个特性可以找出数组的第 k 个元素。

该算法是线性级别的，

```java
public T select(T[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while(h > l) {
        int j = partition(nums, l, h);
        
        if (j == k) {
            return nums[k];
        } else if (j > k) {
            h = j - 1;
        } else {
            l = j + 1;
        }
    } 
    return nums[k];
}
```

# 4. 堆排序

## 1. 堆

堆中某个节点的值总是大于其子节点的值，并且堆是一颗完全二叉树。

推可以用数组表示，这是因为堆是完全二叉树。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。

 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png) 

初始化堆的代码：

```java
package com.eugeo.sort;

/**
 * @author Administrator
 */
public class Heap<T extends Comparable<T>> {
	private T[] heap;
	private int N = 0;

	public Heap(int maxN) {
		this.heap = (T[]) new Comparable[maxN + 1];
	}

	public boolean isEmpty() {
		return N == 0;
	}

	public int size() {
		return N;
	}

	private boolean less(int i, int j) {
		return heap[i].compareTo(heap[j]) < 0;
	}

	private void swap(int i, int j) {
		T t = heap[i];
		heap[i] = heap[j];
		heap[j] = t;
	}

}
```

## 2. 上浮和下沉

在堆中，当一个节点比父节点大，那么就需要交换这两个节点，可能它比新的父节点更大，所以需要不断比较和交换，这种操作称为上浮。

```java
private void swim(int k) {
    //比较父节点与该节点大小
    while (k > 1 && less(k / 2, k)) {
        //交换
        swap(k, k / 2);
        k = k / 2;
    }
}
```

当该节点小的时候则需要不断向下进行比较和交换操作，这种操作称为下沉。交换时应该与更大的节点进行交换。

```java
private void sink(int k) {
    //下沉
    while (k * 2 <= N) {
        //取得子节点
        int j = 2 * k;
        if (j < N && less(j, j + 1)) {
            j++;
        }
        if (!less(k, j)) {
            break;
        }
        swap(k, j);
        k = j;
    }
}
```

### 插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

```java
public void insert(Comparable v) {
    heap[++N] = (T) v;
    swim(N);
}
```

### 删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并将其下沉到合适的位置。

```java
public T delMax() {
    T max = heap[1];
    swap(1, N--);
    heap[N + 1] = null;
    sink(1);
    return max;
}

```

## 3. 堆排序

将最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，就可以得到一个从头到尾的递减序列。

1. 构建堆（ 将无序数组构建成一个小顶堆 ）
2. 将最大元素和最后一个元素交换位置，并使其下沉。

```java
package com.eugeo.sort;

import org.jetbrains.annotations.NotNull;

import java.util.Arrays;

public class HeapSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		int N = nums.length - 1;

		//依次下沉元素, 构建堆
		for (int k = N / 2; k >= 1; k--) {
			sink(nums, k, N);
		}

		//将堆顶元素与末尾元素交换
		while (N > 1) {
			swap(nums, 1, N--);
			sink(nums, 1, N);
		}
	}

	/**
	 * 下沉操作
	 * @param nums 堆数组
	 * @param k    下沉元素下标
	 * @param N    堆数组大小
	 */
	private void sink(T[] nums, int k, int N) {
		// 选定其叶子节点
		while (2 * k <= N) {
			int j = 2 * k;
			if (j < N && less(nums, j, j + 1)) {
				j++;
			}
			if (!less(nums, k, j)) {
				break;
			}
			swap(nums, k, j);
			k = j;
		}
	}

	boolean less(T[] nums, int i, int j) {
		return nums[i].compareTo(nums[j]) < 0;
	}

	public static void main(String[] args) {
		HeapSortApp<Integer> sortApp = new HeapSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23,56456,45642,121,5,2,48426,2154,65};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
}
```

## 4. 分析

一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

堆排序，因为要对 N 个节点进行下沉操作，因此复杂度为 $N \log{N}$ 。

堆排序为原地排序，没有利用额外空间。

现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。

# 小结

# 1. 排序算法的比较

| 算法             | 稳定性 | 时间复杂度                   | 空间复杂度 | 备注                     |
| ---------------- | ------ | ---------------------------- | ---------- | ------------------------ |
| 选择排序         | ×      | N2                           | 1          |                          |
| 冒泡排序         | √      | N2                           | 1          |                          |
| 插入排序         | √      | N ~ N2                       | 1          | 时间复杂度和初始顺序有关 |
| 希尔排序         | ×      | N 的若干倍乘于递增序列的长度 | 1          | 改进版插入排序           |
| 快速排序         | ×      | NlogN                        | logN       |                          |
| 三向切分快速排序 | ×      | N ~ NlogN                    | logN       | 适用于有大量重复主键     |
| 归并排序         | √      | NlogN                        | N          |                          |
| 堆排序           | ×      | NlogN                        | 1          | 无法利用局部性原理       |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

## 2. Java 的排序算法实现

Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。 



参考

 https://www.cnblogs.com/chengxiao/p/6194356.html

[https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F?id=%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f](https://cyc2018.github.io/CS-Notes/#/notes/算法 - 排序?id=选择排序)