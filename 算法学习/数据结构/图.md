# 图

图论应用：

地图， 网页信息， 电路，任务调度，商业交易，配对，计算机网络，软件，社交网络。

图是由一组顶点和一组能够将两个顶点相连的边组成的。

术语表：

当两个顶点( vertex ) 通过一条边相连时，我们称这两个顶点是相邻的，并称这条边依附于两个顶点。某个顶点的**度数**即为依附于它的边的总数。子图是由一幅图的所有边的一个子集组成的图。

**路径**是由边顺序连接的一系列顶点。**简单路径**是一条没有重复顶点的路径。环是一条至少含有一条边且起点和终点相同的路径。**简单环** 是一条不含重复顶点和边的环。

当且仅当一幅含有 V 个节点的图 G 满足下列五个条件之一时，它就是一棵树：

1. G 有 V-1 条边且不含有环
2. G 有 V-1 条边且是连通的
3. G 是连通的，但删除任意一条边都会使它不在连通
4. G 是无环图，但添加任意一条边都会产生一条环
5. G 中的任意一对顶点之间仅存在一条简单路径

图的集中表示方法

1. 邻接矩阵：缺点：无法预留出足够的空间
2. 邻接表：能满足上下的缺点，经常使用
3. 边数组： 缺点：实例方法实现慢（ adj() 方法需要检查所有边 ）

# 无向图

图的边没有方向

API：

```java
/**
 * 无向图实现
 * @author Administrator
 */
public class Graph {
	private final int V; //顶点数目
	private int E;  //边的数目
	private Bag<Integer>[] adj; //邻接表

	public Graph(int V) {
		this.V = V;
		this.E = 0;
		//创建邻接表
		adj = (Bag<Integer>[]) new Bag[V];
		for (int v = 0; v < V; v++) {
			adj[v] = new Bag<>();
		}
	}

	/**
	 * @return 顶点数
	 */
	public int V() {
		return V;
	}

	/**
	 * @return 边数
	 */
	public int E() {
		return E;
	}

	/**
	 * 向图中添加一条边 v-w
	 * @param v 顶点 v
	 * @param w 顶点 w
	 */
	public void addEdge(int v, int w) {
		//将 w 添加到 v 的链表中
		adj[v].add(w);
		//将 v 添加到 w 的链表中
		adj[w].add(v);
		E++;
	}

	public Iterable<Integer> adj(int v) {
		return adj[v];
	}

	@Override
	public String toString() {
		return "Graph{" +
				"V=" + V +
				", E=" + E +
				", adj=" + Arrays.toString(adj) +
				'}';
	}
}
```

## 1. 深度优先搜索

使用递归方法遍历所有顶点。在访问其中一个顶点时：

1. 将它标记为已访问
2. 递归地访问它的 所有没有被标记过的邻居顶点

```java
public class DepthFirstSearch
{
    private boolean[] marked;
    private int count = 0;
    
    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }
    
    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (int w : G.adj(v)) {
            if(! marked[w])
                dfs(G, w);
        }
    }
    
    public boolean marked(int w) {
        return marked[w];
    }
    
    public int count() {
        return count;
    }
}
```

## 2. 广度优先搜索

解决单点最短路径（ 边数最少的路径 ）出现的算法

```java
public class BreadthFirstPaths {
    private boolean[] marked;
    // 到达该顶点的已知路径上的最后一个顶点
    private int[] edgeTo;
    //起点
    private final int s;
    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        bfs(G, s);
    }
    
    private void bfs(Graph G, int s) {
        Queue<Integer> queue = new Queue<Interger>();
        //标记起点
        marked[s] = true;
        //将它加入队列
        queue.enqueue(s);
        while(!queue.isEmpty()) {
            // 从队列中删去下一个顶点
            int v = queue.dequeue();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    // 保存最短路径的最后一条边
                    edgeTo[w] = v;
                    // 标记它，因为最短路径已知
                    marked[w] = true;
                    // 将他添加入队列
                    queue.enqueue(w);
                }
            }
        }
    }
}
```

# 最小生成树

图的生成树是它的一颗含有其所有顶点的无环连通子图。一幅加权图的最小生成树（ MST ）是它的一颗权值最小的生成树。

树的两个重要性质

1. 用一条边连接树中的任意两个顶点都会产生一个新的环
2. 从树中删去一条边将会得到两颗独立的树

切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。

## 1. Prim 算法

`Prim`算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。`Prim`算法在找当前最近顶点时使用到了贪婪算法。

算法描述：

1. 在一个加权连通图中，顶点集合`V`，边集合为`E`
2. 任意选出一个点作为初始顶点,标记为`visit`,计算所有与之相连接的点的距离，选择距离最短的，标记`visit`.
3. 重复以下操作，直到所有点都被标记为`visit`：
     在剩下的点钟，计算与已标记`visit`点距离最小的点，标记`visit`,证明加入了最小生成树。

## 2. Kruskal  算法

此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。
1. 把图中的所有边按代价从小到大排序；
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

