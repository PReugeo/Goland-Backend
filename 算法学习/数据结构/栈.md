# 概念

栈是一种基于先进后出（ LIFO ）策略的集合类型。

方法有

1. push

    压入，将新元素压入栈顶端。

2. pop

    弹出，将第一个元素（ 最新的 ）弹出。

# 应用

算术表达式求值，用集合保存元素的同时颠倒它们的相对顺序。

# Java 实现

## 栈接口设计

```java
package com.eugeo.myStack;

/**
 *继承 Iterable 是使类可迭代，即可完成 foreach 语句迭代。
 */
public interface MyStack<Item> extends Iterable<Item> {

	/**
	 * 压入栈操作
	 * @param item 需要压入的元素
	 * @return 压入元素后的栈
	 */
	MyStack<Item> push(Item item);

	/**
	 * 弹出元素操作
	 * @return 弹出的元素
	 * @throws Exception 元素不存在 Exception
	 */
	Item pop() throws Exception;

	/**
	 * 判断该栈是否为空
	 * @return 是否为空
	 */
	boolean isEmpty();

	/**
	 * 返回栈的大小
	 * @return 栈的大小
	 */
	int size();
}
```

## 数组栈的实现

```java
package com.eugeo.myStack;

import org.jetbrains.annotations.NotNull;

import java.util.Iterator;

/**
 * 栈的数组实现
 */
public class ArrayStack<Item> implements MyStack<Item> {
	/**
	 * 栈元素数组，只能通过转型来创建泛型数组
	 * 否则会报错，即无法直接创建泛型数组。
	 */
	private Item[] a = (Item[]) new Object[1];

	/**
	 * 元素数量
	 */
	private int N = 0;

	@Override
	public MyStack<Item> push(Item item) {
		check();
		a[N++] = item;
		return this;
	}

	@Override
	public Item pop() throws Exception {
		if (isEmpty()) {
			throw new Exception("stack is empty");
		}

		Item item = a[--N];

		check();
		//避免对象游离
		a[N] = null;

		return item;
	}

	@Override
	public boolean isEmpty() {
		return N == 0;
	}

	@Override
	public int size() {
		return N;
	}

	private void check() {
		if (N >= a.length) {
			resize(2 * a.length);
		} else if (N > 0 && N <= a.length / 4) {
			resize(a.length / 2);
		}
	}

	/**
	 * 调整数组大小，使栈具有伸缩性
	 * @param size 伸缩的大小
	 */
	private void resize(int size) {
		Item[] tmp = (Item[]) new Object[size];

		if (N >= 0) {
			System.arraycopy(a, 0, tmp, 0, N);
		}

		a = tmp;
	}

	@NotNull
	@Override
	public Iterator<Item> iterator() {
		return new Iterator<Item>() {
			private int i = N;

			@Override
			public boolean hasNext() {
				return i > 0;
			}

			@Override
			public Item next() {
				return a[--i];
			}
		};
	}
}
```

`a[N]=null` 用于避免对象游离，Java 的垃圾回收策略是回收所有无法被访问的内存，pop() 实现中，被弹出的元素的引用仍在数组中，可能无法被垃圾回收，这种情况被称为对象游离（ 保存一个不需要对象的引用 ），直接将其设置为 null 可以让 Java 垃圾回收器回收它的内存。

## 链表栈的实现

使用链表头插法实现，因为头插法中最后压入栈的元素在栈的开头，它的 next 指针指向前一个压入栈的元素，在弹出元素时可以通过 next 指针遍历到前一个压入栈的元素从而让其成为新的栈顶元素。

```java
/**
 * @author Administrator
 */
public class ListStack<Item> implements MyStack<Item> {
	/**
	 * 链表元素
	 */
	private class Node {
		Item item;
		Node next;
	}

	/**
	 * 头指针
	 */
	private Node top = null;
	private int N = 0;

	@Override
	public MyStack<Item> push(Item item) {
		Node newTop = new Node();

		newTop.item = item;
		newTop.next = top;

		top = newTop;

		N++;

		return this;
	}

	@Override
	public Item pop() throws Exception {
		if (isEmpty()) {
			throw new Exception("stack is empty");
		}

		Item item = top.item;

		top = top.next;
		N--;

		return item;
	}

	@Override
	public boolean isEmpty() {
		return N == 0;
	}

	@Override
	public int size() {
		return N;
	}

	@NotNull
	@Override
	public Iterator<Item> iterator() {
		return new Iterator<Item>() {
			private Node cur = top;

			@Override
			public boolean hasNext() {
				return cur != null;
			}

			@Override
			public Item next() {
				Item item = cur.item;
				cur = cur.next;
				return item;
			}
		};
	}
}

```

