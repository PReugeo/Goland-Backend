# 1. 概述

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。

顾名思义就是有“合并集合”和“查找集合”两种操作的关于数据结构的一种算法。



# 2. 性质

并查集算法不支持分割一个集合

# 3. 算法目的

## 算法目的

能够在如下条件下高效解决动态连接的问题

- `Union`命令和`Find`命令可能交替被调用   
- 操作的总数`M`可能很大   
- 集合中的对象数目`N`可能很大  

能动态连接两个点，并且判断两个点是否连通

## 算法思想

用集合中的某个元素来代表这个集合，该元素称为集合的代表元。
一个集合内的所有元素组织成以代表元为根的树形结构。
对于每一个元素 parent[x] 指向 x 在树形结构上的父亲节点。如果 x 是根节点，则令parent[x] = x。
对于查找操作，假设需要确定 x 所在的的集合，也就是确定集合的代表元。可以沿着parent[x] 不断在树形结构中向上移动，直到到达根节点。

判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。

## 用途

1、维护无向图的连通性。支持判断两个点是否在同一连通块内，和判断增加一条边是否会产生环。
2、用在求解最小生成树的Kruskal算法里。



# 4. 实现

## 1. Quick Find

快速进行 find 操作。

需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其联通性。

但是 union 操作代价很高，需要将其中一个连通分量中的所有节点 id 值都修改成另一个节点的 id 值。 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0972501d-f854-4d26-8fce-babb27c267f6.jpg) 

```java
package com.eugeo.unionFind;

/**
 * @author Administrator
 */
public class QuickFind extends UF {

	/**
	 * 初始化构造一个大小为 N 的并查集
	 *
	 * @param N 并查集的大小
	 */
	public QuickFind(int N) {
		super(N);
	}

	@Override
	public int find(int p) {
		return id[p];
	}

	@Override
	public void union(int p, int q) {
		int pId = find(p);
		int qId = find(q);

		if (pId == qId) {
			return;
		}

		for (int i = 0; i < id.length; i++) {
			if (id[i] == pId) {
				id[i] = qId;
			}
		}

	}
}

```

## 2. Qucik Union

快速连通，只需要修改一个节点的 id 值。

但是 find 消耗较大需要沿着树向上一直查找，直到查找到最上层的节点。



 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11b27de5-5a9d-45e4-95cc-417fa3ad1d38.jpg) 



```java
package com.eugeo.unionFind;

/**
 * @author Administrator
 */
public class QuickUnion extends UF {

	/**
	 * 初始化构造一个大小为 N 的并查集
	 *
	 * @param N 并查集的大小
	 */
	public QuickUnion(int N) {
		super(N);
	}

	@Override
	public int find(int p) {
		while (p != id[p]) {
			p = id[p];
		}
		return p;
	}

	@Override
	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);

		if (pRoot != qRoot) {
			id[pRoot] = qRoot;
		}
	}
}

```

## 3. 加权 Quick Union

为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。

理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN

```java
package com.eugeo.unionFind;

/**
 * @author Administrator
 */
public class WeightedQuickUnion extends UF {

	/**
	 * sz 用来储存节点的数量（权重）
	 */
	private int[] sz;

	/**
	 * 初始化构造一个大小为 N 的并查集
	 *
	 * @param N 并查集的大小
	 */
	public WeightedQuickUnion(int N) {
		super(N);
		this.sz = new int[N];
		for (int i = 0; i < N; i++) {
			this.sz[i] = 1;
		}
	}

	@Override
	public int find(int p) {
		while (p != id[p]) {
			p = id[p];
		}

		return p;
	}

	@Override
	public void union(int p, int q) {
		int i = find(p);
		int j = find(q);

		if (i == j) {
			return;
		}

		if (sz[i] < sz[j]) {
			id[i] = j;
			sz[j] += sz[i];
		} else {
			id[j] = i;
			sz[i] += sz[j];
		}

	}
}

```

## 4. 路径压缩的加权 Quick Union

在检查节点的同时将它们链接到根节点，只需要在 find 中添加一个循环即可。

```java
/**
* 路径压缩
* @param p 节点 p
* @return p 所在路径
*/
@Override
public int find(int p) {
    while (p != id[p]) {
        //让父节点作为根节点
        id[p] = id[id[p]];
        p = id[p];
    }
    return p;
}

```





## 比较

| 算法                       | union      | find       |
| -------------------------- | ---------- | ---------- |
| Quick Find                 | N          | 1          |
| Quick Union                | 树高       | 树高       |
| 加权 Quick Union           | logN       | logN       |
| 路径压缩的加权 Quick Union | 非常接近 1 | 非常接近 1 |