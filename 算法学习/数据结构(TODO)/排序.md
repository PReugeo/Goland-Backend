# 1. 希尔排序

希尔排序是插入排序的改进版本。

希尔排序通过交换不相邻的元素，每次将逆序数量减少大于 1。希尔排序是非稳定排序（ 即排序后具有相同值的元素的位置可能不一样 ）。

希尔排序通过使用插入排序对间隔 h 的序列进行排序。通过不断减少 h，最后令 h = 1，就可以使整个数组有序。

代码：

```java
/**
 * 希尔排序
 * @author Administrator
 */
public class ShellSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		int n = nums.length;
		int h = 1;
		int s = 3;

		while (h < n / s) {
			h = s * h - 1;  //设置 h 初值
		}

		while (h >= 1) {
			for (int i = h; i < n; i++) {
				for (int j = i; j >= h && less(nums[j], nums[j - h]); j -= h) {
					swap(nums, j, j - h);
				}
			}
			h /= s;
		}
	}

	public static void main(String[] args) {
		ShellSortApp<Integer> sortApp = new ShellSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
```

时间复杂度：$O(n^{(1.3-2)})$ ，空间复杂度：$O(1)$

# 2. 归并排序

归并排序是利用归并的思想实现的排序算法，算法采用经典的分支策略（分治法就是将问题分解为小问题然后进行递归求解，而治的阶段就是将分的阶段得到的各答案修补在一起）。

归并排序是稳定排序。

![img](D:\Java-golang-learning\算法学习\数据结构(TODO)\数据结构.assets\分治法.png)

代码：

```java
/**
 * @author EugeoY
 */
public class MergeSortApp<T extends Comparable<T>> extends BaseSort<T> {
	protected T[] aux;

	protected void merge(T[] nums, int l, int m, int h) {
		//左序列指针
		int i = l;
		//右序列指针
		int j = m + 1;

		if (h + 1 - l >= 0) {
			//复制数据到辅助数组
			System.arraycopy(nums, l, aux, l, h + 1 - l);
		}

		for (int k = l; k <= h; k++) {
			if (i > m) {
				nums[k] = aux[j++];

			} else if (j > h) {
				nums[k] = aux[i++];

			} else if (aux[i].compareTo(aux[j]) <= 0) {
				//保证稳定性
				nums[k] = aux[i++];
			} else {
				nums[k] = aux[j++];
			}
		}

	}


	@Override
	public void sort(T[] nums) {
		aux = (T[]) new Comparable[nums.length];

		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

        //将数组拆分为一半后进行合并
		int mid = l + (h - l) / 2;
		sort(nums, l, mid);
		sort(nums, mid + 1, h);
		merge(nums, l, mid, h);
	}

	public static void main(String[] args) {
		MergeSortApp<Integer> sortApp = new MergeSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
}
```



时间复杂度为 $O(n \log n)$ 



# 3. 快速排序

快速排序思想：通过一趟排序把要排序的数据分割成两部分，其中一部分所有数据都比另一部分的所有数据小，再用这种方法对两部分数据分别进行快速排序，整个过程 可以递归进行，使整个数据变成有序序列。

是典型的分支思想。

**算法步骤**

1. 从待排序数组中选取一个“ 基准 ” 元素
2. 重新排序数组，所有比基准小的摆在基准前面，大的放后面，在这之后该基准就处于数组中间位置，这个操作称为分区( partition )
3. 递归把小于基准的子数组和大于基准的大数组排序

**代码实现（ Java ）**

```java
ppublic class QuickSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		shuffle(nums);
		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

		int j = partition(nums, l, h);
		sort(nums, l, j - 1);
		sort(nums, j + 1, h);
	}

    //随机打乱数组顺序，使基准元素的元素随机
	private void shuffle(T[] nums) {
		List<Comparable> list = Arrays.asList(nums);
		Collections.shuffle(list);
		list.toArray(nums);
	}
    
	//分区操作
	private int partition(T[] nums, int l, int h) {
		int i = l, j = h + 1;
		T v = nums[l];
		while (true) {
			while (less(nums[++i], v) && i != h);
			while (less(v, nums[--j]) && j != l);
			if (i >= j) {
				break;
			}
			swap(nums, i, j);
		}
		swap(nums, l, j);
		return j;
	}

	public static void main(String[] args) {
		QuickSortApp<Integer> sortApp = new QuickSortApp<>();
		Integer[] nums = {2, 564, 45, 231, 564, 23,56456,45642,121,5,2,48426,2154,65};
		sortApp.sort(nums);
		System.out.println(Arrays.toString(nums));
	}
}
```

快速排序是原地排序，不需要辅助数组，但是递归调通需要辅助栈。

平均算法复杂度$O(n \log n)$ ，最坏情况是第一次从最小元素切分，第二次从第二小元素切分，最坏需要比较 $\frac{N^2}{2}$ 次，所以为了反之数组开始有序，在快速排序前需要随机打乱数组。

##  快排的改进

### 3.1 切换到插入排序

因为快速排序在==小数组==中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。

### 3.2 三数取中

最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。

### 3.3 三向切分

对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。

三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。

```java
package com.eugeo.sort;

public class ThreeWayQuickSortApp<T extends Comparable<T>> extends BaseSort<T> {
	@Override
	public void sort(T[] nums) {
		sort(nums, 0, nums.length - 1);
	}

	private void sort(T[] nums, int l, int h) {
		if (h <= l) {
			return;
		}

		int lt = l, i = l + 1, gt = h;
		T v = nums[l];
		while (i <= gt) {
			int cmp = nums[i].compareTo(v);
			if (cmp < 0) {
				swap(nums, lt++, i++);
			}  else if (cmp > 0) {
				swap(nums, i, gt--);
			} else {
				i++;
			}
		}
		sort(nums, l, lt - 1);
		sort(nums, gt + 1, h);
	}
}
```

## 基于切分的快速选择算法





参考

 https://www.cnblogs.com/chengxiao/p/6194356.html

[https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F?id=%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f](https://cyc2018.github.io/CS-Notes/#/notes/算法 - 排序?id=选择排序)