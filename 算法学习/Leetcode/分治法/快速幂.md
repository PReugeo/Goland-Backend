# 题目描述

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

**说明:**

-   -100.0 < *x* < 100.0
-   *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。



# 解题思路

本题解题方法为 `快速幂算法` ，有递归和迭代两个版本。当指数 n 为负数时，我们可以计算 $x^{-n}$ 再取倒数得到结果。

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x^{64}*x*64，我们可以按照：
$$
x \to x^2 \to x^4 \to x^8 \to x^{16} \to x^{32} \to x^{64}
$$
的顺序，从 x*x* 开始，每次直接把上一次的结果进行平方，计算 66 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 6363 次 x。

再举一个例子，如果我们要计算 $x^{77}$，我们可以按照：
$$
x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}
$$
的顺序，在 $x \to x^2$，$x^2 \to x^4$，$x^{19} \to x^{38}$ 这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9，x^9 \to x^{19}，x^{38} \to x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。



如果是从左到右推导看起来很困难，因为在每一步后，不知道平方后还需不需要乘以 x，但如果从右往左看，分治的思想就十分明显了：

-   当我们要计算 $x^n$ 时，我们可以先递归地计算出$$ y = x^{\lfloor n/2 \rfloor}$$，其中$$ \lfloor a \rfloor$$ 表示对 $a$ 进行下取整；
-   根据递归计算的结果，如果 n为偶数，那么 $x^n = y^2$；如果 n 为奇数，那么 $x^n = y^2$ 
-   递归的边界为 $n = 0$，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为$$ O(\log n)$$，算法可以在很快的时间内得到结果。



递归代码

```go
func myPow(x float64, n int) float64 {
    if n > 0 {
        return quickMul(x, n)
    }
    return 1.0 / quickMul(x, n)
}

func quickMul(x float64, n int) float64 {
    if n == 0 {
        return 1
    }

    y := quickMul(x, n / 2)
    if n % 2 == 0 {
        return y * y
    }
    return y * y * x
}
```

非递归代码, 在循环过程中将二进制位 1 时对应的幂累加到答案中

```go
func myPow(x float64, n int) float64 {
    ans := float64(1)
    if n < 0 {
        x = 1 / x
        n = -n
    }

    for n > 0 {
        if n & 1 != 0 {
            ans *= x
        }
        n >>= 1
        x *= x
    }
    return ans
}

```

