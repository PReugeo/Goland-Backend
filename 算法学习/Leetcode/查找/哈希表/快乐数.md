# 题目描述

编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `True` ；不是，则返回 `False` 。

**示例：**

```fortran
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```



# 解题思路

## HashSet 法

使用 `HashSet` 检测循环，因为每一位的平方相加会有以下三种可能：

1.  最终会得到 1。
2.  最终会进入循环。
3.  值会越来越大，最后接近无穷大。

第三种情况比较难处理，但是，值不会变成无穷大，由下表可得，所以我们只需要处理第二种情况

| Digits |    Largest    | Next |
| ------ | :-----------: | ---: |
| 1      |       9       |   81 |
| 2      |      99       |  162 |
| 3      |      999      |  243 |
| 4      |     9999      |  324 |
| 13     | 9999999999999 | 1053 |

第二种情况，我们可以使用哈希表来存储检测循环，每一个 n 都存入哈希表的 `key` 中，一旦有了重复循环则退出循环，进行判断 `n == 1` 。



代码

```go
func isHappy(n int) bool {
    m := map[int]bool{}

    for ; n != 1 && !m[n]; n, m[n] = step(n), true { 
        
    }
    return n == 1 

}

func step(n int) int {
    sum := 0
    for n > 0 {
        sum += (n % 10) * (n % 10)
        n /= 10 
    }
    return sum
}
```

>   但是在这种循环问题中建议使用快慢指针，因为 `map[int]` 是有大小限制的。

## 快慢指针法 

快慢指针法检测循环，在于快指针每次跳两步，慢指针每次跳一步，如果存在循环则快慢指针一定会在某个点相遇

```go
func isHappy(n int) bool {
    slow, fast := n, step(n)
    
    for fast != 1 && fast != slow {
        slow = step(slow)
        fast = step(step(fast))
    }
    
    return fast == 1

}

func step(n int) int {
    sum := 0
    for n > 0 {
        sum += (n % 10) * (n % 10)
        n /= 10 
    }
    return sum
}
```

