# 问题描述

给你一个可装载重量为 `W` 的背包和 `N` 个物品，每个物品有重量和价值两个属性。其中第 `i` 个物品的重量为 `wt[i]`，价值为 `val[i]`，现在让你用这个背包装物品，最多能装的价值是多少？

# 解决方案

这是一个典型动态规划问题，题目中物品不可分割，要么装进包里，要么不能装。

解决这个问题只能穷举所有可能，所以直接通过动态规划套路走

## 动态规划标准套路：

**第一步首先明确**， `[状态]` 和 `[选择]` ：

该问题为几个物品和一个背包的容量限制，所以状态有两个，就是 `[背包的容量]` 和 `[可选择的物品]` 

对于物品而言： 选择只有 `装进背包` 和 `不装进背包` 两种状态。

套路框架：

```go
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

**第二步要明确 `dp` 数组的定义**

刚刚确定的状态有两个，所以 `dp` 数组是二维数组。

`dp[i][w]` 的定义如下：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`。

比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。

根据这个定义，我们想求的最终答案就是 `dp[N][W]`。base case 就是 `dp[0][..] = dp[..][0] = 0`，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

细化框架：

```java
int dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

**第三步，根据选择，思考状态转移的逻辑**

# 

`dp[i][w]` 的定义如下：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`。

如果第 i 个物品未装入背包，最大价值 `dp[i][w]` 应该等于 `dp[i-1][w]` 的最大价值，继承之前的结果。

如果第 i 个物品装入了背包，最大价值 `dp[i][w]` 应该等于 `dp[i-1][w-wt[i]] + val[i-1]` 

因为 i 是从 1 开始，所以 `wt[i-1]` 和 `val[i-1]` 表示第 i 个物品的重量和价值。

所以细化伪代码：

```java
int dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w-wt[i-1] + val[i-1],
            dp[i-1][w]
        )
return dp[N][W]
```

# 代码

```go
func knapsack(w int, n int, wt []int, val []int) int {
    var dp [n+1][w+1]int
    for i = 1; i <= N; i++ {
        for j = 0; j <= w, j++ {
            if w - wt[i-1] < 0 {
                dp[i][w] = dp[i-1][w]
            } else {
                dp[i][w] = max(dp[i-1][w-wt[i-1] + val[i-1],
            dp[i-1][w])
            }
        }
    }
                                       
    return dp[n][w]
}
```

