参考自https://github.com/CyC2018/CS-Notes 

# 虚拟内存

虚拟内存是让物理内存扩大成更大的逻辑内存，让程序获得更多可用内存。

OS 将内存抽象为地址空间，每个程序都有自己的地址空间，**一块地址空间被称为一页**。这些页被映射到物理内存中，不需要映射到连续地址空间中也不一定要在物理内存上。但程序用到不存在物理内存上的内存时，由硬件执行映射（ 使用页面置换算法 ），将缺失部分转入物理内存并重新执行失败的指令。

虚拟内存允许不用每一页地址空间都映射到物理内存上，使电脑可以在有限的内存中执行大程序。

# 分页系统地址映射

内存管理单元（ MMU ）管理地址空间与物理内存转换，其中页表存储着页（ 程序地址空间 ），和页框（ 物理内存 ）的映射表。

# 页面置换算法

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

## 1.最佳（ OPT ）

所选择的被换出的页面将是最长时间内不再访问的页，通常可以保证最低的缺页率。

是一种理论的算法，因为无法知道一个页多长时间不再被访问。



## 2.最近最久未使用（ LRU ）

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

## 3.最近未使用 （ NRU）

 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类： 

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

## 4.先进先出 （ FIFO ）

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

## 5.第二次机会算法

 FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改： 

 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 

## 6.时钟

 第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 

![img](..\java\static\时钟.png)

# 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 

编译器在编译过程建立多个表如果表是动态增长的如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

分段做法为把每个表分成段，一个段构成一个独立的地址空间，每个段长度可以不同且可以动态增长。

# 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。



# 分页和分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。